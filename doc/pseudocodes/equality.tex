\subsection{Proof of equality of discrete logarithm representation}

This is the protocol for proving knowledge of the equality of discrete logarithm representations of some numbers using some well-defined bases in an honest verifier zero knowledge way. The Verifier knows the bases. We call this protocol \textbf{PoEoDLR}. it has two versions:

The first version uses Fujisaki-Okamoto commitments. Therefore it requires the same setup and the same assumptions. Everything said for the Fujisaki-Okamoto commitments also applies there.

The second version uses Pederson commitments. Therefore it requires the same setup and the same assumptions. Everything said for the Pederson commitments also applies there.

All operations will be done in respective groups.


\textsc{Assumptions}:\\
RSA group version makes the Strong RSA assumption.\\
Prime-order group version makes no assumptions.


\textsc{Honest-Verifier Zero Knowledge}:\\
RSA group version is honest verifier zero knowledge provided that the Fujisaki-Okamoto commitment is hiding. This means that the RSA group must be generated by a trusted third party or it must be proven to the Prover that each $g_i,h$ generates $QR_n$.\\
Prime-order group version is honest verifier zero knowledge provided that the Pedersen commitment is hiding. This means that the prime-order group must be generated by a trusted third party or the Prover must verify that each $g_i,h$ has order $ \primeOrder $.



\textsc{Soundness}:\\
In RSA group version, the extraction works under the Strong RSA assumption, which requires that the RSA group may NOT be generated by the Prover.\\
In prime-order group version, the extraction works without any assumption.



\textsc{*Warnings}:\\
In many uses of the prime-order group version of this protocol, for it to be meaningful, we would like the Pedersen commitments to be binding, which means the Prover may NOT generate $g_i,h$ (and thus know the relative discrete logarithms of the bases), and that the Discrete Logarithm assumption holds.



\begin{algorithm}[H]\label{randProofPoEoDLR}
\SetKwComment{Comment}{}{}
\dontprintsemicolon

\KwIn{Definition of the group, bases $g_1,...,g_k,h$, number of common secrets $k$, number other secrets $l$}
\KwOut{randomized proof set $R$, its opening set $openR$}
\BlankLine

\Comment{Randomize Proof} \;
\Indp
  \For{$i$ : $1..k$}
    {Pick a random number $s_i$ from domain of randomness $D_R$. \;}
  \For{$i$ : $1..l$}
    {Create the randomized proof $R_i$ to using Randomize(group definition, $1$ (number of random elements), $k$ (number of fixed elements), $g_1,...g_k,h$ (bases), $s_1,\ldots,s_k$ (fixed elements)). Let the opening returned by the Commit procedure be $openR_i = s_1,\ldots,s_k,t_i$. \;}
  Output randomized proof set $R$ (set of $R_i$'s) and opening set $openR$ (set of $openR_i$'s). \;
\Indm

\caption{Randomized Proof round of PoEoDLR protocol. This procedure is run by the Prover.}
\end{algorithm}



\begin{algorithm}[H]\label{respondPoEoDLR}
\SetKwComment{Comment}{}{}
\dontprintsemicolon

\KwIn{Definition of the group, f the group, bases $g_1,...,g_k,h$, number of common secrets $k$, number other secrets $l$, common secrets $x_1,\ldots,x_k$ and other secrets $r_1,\ldots,r_l$, openings of randomized proofs $openR_1\ldots openR_l$ where $openR_j = s_1,\ldots,s_k,t_j$, challenge $c$}
\KwOut{set of responses $A = a_1,\ldots,a_m$}
\BlankLine

\Comment{Respond} \;
\Indp
  \For{$i$ : $1..k$}
    {Compute $a_i = s_i + c x_i$ \;}
  \For{$j$ : $1..l$}
    {Compute $b_j = t_j + c r_j$ \;}
  If no RSA group is involved, let $ a_i = a_i \mod \primeMod $ and $ b_i = b_i \mod \primeMod $ \;
  Output response $A = a_1,\ldots,a_k,b_1,\ldots,b_l$ \;
\Indm

\caption{Response round of PoEoDLR protocol. This procedure is run by the Prover.}
\end{algorithm}



\begin{algorithm}[H]\label{verifyPoEoDLR}
\SetKwComment{Comment}{}{}
\dontprintsemicolon

\KwIn{Definition of the group, number of common secrets $k$, number of other secrets $l$, bases $g_1,\ldots,g_k,h$, set of commitments $C = C_1,\ldots C_l$, set of randomized proofs $R = R_1,\ldots R_l$, challenge $c$, response $A = a_1,\ldots,a_k,b_1,\ldots,b_l$}
\KwOut{$\accept$ or $\reject$}
\BlankLine

\Comment{Verify} \;
\Indp
  \If{$R_1 C_1^c = h^{b_1} \prod_{i=1}^{k} g_i^{a_i}$ AND $\ldots$  AND $R_l C_l^c = h^{b_l} \prod_{i=1}^{k} g_i^{a_i}$}
    {Output $\accept$ \;}
  \Else
    {Output $\reject$ \;}
\Indm

\caption{Verification of PoEoDLR protocol. This procedure is run by the Verifier upon receipt of response $A$ from the Prover.}
\end{algorithm}



\paragraph{The Simulator} Here we present a simulator to simulate a 2-base equality of discrete logarithm representation protocol. The purpose of the simulator is to show that an entity starting with knowledge of the challenge but not the secrets can simulate the Prover's work to the Verifier. This is turn shows that with an honest Verifier, the process of proving is zero-knowledge and gives no extra information about the secrets to the Verifier, because the Simulator does not know any more about the secrets than the Verifier does.

\noindent$a,b,d$ - the three secrets \\
$g,h$ - the group bases/ generators \\
$A = g^ah^b$ - commitment 1 \\
$B = g^ah^d$ - commitment 2 \\
$o$ - group order\\
$m$ - group modulus\\
$c$ - the challenge that the Verifier will send\\


\begin{tabular}{|l|l|l|l|l|}
\hline
\textbf{the simulator} & $S$ & & $V$ & \textbf{the verifier} \\
\hline
\multirow{2}{*}{}
starting & $g,h,A,B,o,m,c$ & & $g,h,A,B,o,m$ & starting \\
information & & & & information \\
% & group description & & group description & \\ $g,h,A,B,o,m,c$,\\group description & $g,h,A,B,o,m$,\\group description & starting information \\
\hline
\multirow{3}{*}{}
$S$ picks & pick random $r_1,r_2,r_3$ & & & \\
responses & s.t. $1 \leq r_i \leq o-1$ $\forall i$ & & & \\
ahead of time & $s_1 = r_1$, $s_2 = r_2$, $s_3 = r_3$ & & & \\
%$S$ picks responses ahead of time & $S$ picks random $r_1,r_2,r_3$ s.t. $1 \leq r_i \leq o-1$ $\forall i$. $s_1 = r_1$, $s_2 = r_2$, $s_3 = r_3$ & & & \\
\hline
\multirow{5}{*}{}
$S$ computes & $R_A = g^{r_1}h^{r_2}A^{-c}$ & & & \\
randomized & $R_B = g^{r_1}h^{r_3}B^{-c}$ & & & \\
proofs based & & $\underrightarrow{R_A,R_B}$ & & \\
on responses & & & & \\
and challenge $c$ & & & & \\

%$S$ computes randomized proofs based on responses and challenge $c$ & $R_A = g^{r_1}h^{r_2}A^{-c}$, $R_B = g^{r_1}h^{r_3}B^{-c}$. & $\overrightarrow{R_A,R_B}$ & & \\
\hline
\multirow{1}{*}{}
 & & $\underleftarrow{c}$ & pick $c\in D_c$ & \\
\hline
\multirow{3}{*}{}
$S$ sends back & & & $R_AA^c == g^{s_1}h^{s_2} \mod p$ & check that \\
pre-computed & & $\underrightarrow{r_1,r_2,r_3}$ & $R_BA^c == g^{s_1}h^{s_3} \mod p$ & all these \\
responses & & & & equal \\
\hline
\multirow{4}{*}{}
 & & & & if equal \\
 & & & & \verb -> \textbf{accept}\\
 & & & & if not \\
 & & & & \verb -> \textbf{reject} \\
\hline
\end{tabular}

