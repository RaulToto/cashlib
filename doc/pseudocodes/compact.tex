\subsection{Compact E-Cash}

Compact E-Cash \cite{chlCOMPACT} enables a user to withdraw a wallet containing many coins at once. But, the coins need to be spent one by one. Some extensions addressing this issue will be discussed later. Using offline Compact E-Cash, the Bank can find the public keys of double-spenders. Double deposits can easily be detected using serial numbers. The use of CL signatures assure that the serial numbers are not known to the Bank during the withdrawal process, and hence the anonimity of an honest user is guaranteed.

Compact E-Cash works with a prime-order group, and utilizes CL signatures, so uses a special RSA group for the purposes of CL signatures. It's important that the $\orderLength \leq l_x$, the CL signature message length.

Below, we will present a slightly modified version of Compact E-Cash. The modifications keep the scheme secure, while improving its efficiency greatly.


\textsc{Assumptions}:\\
Compact E-cash works in the Random Oracle model and makes Discrete Logarithm and Strong RSA assumptions, and also the following assumptions:

q-Decisional Diffie-Hellman Inversion Assumption:



\subsubsection{Register}
Every user must register with the Bank her public key. This is a very simple protocol, where the User just picks a random secret key $ 1 < sk_u < \primeOrder $ and sends her public key $ pk_u = g^{sk_u} \mod \primeMod $ to the Bank. The Bank registers the User's public key in a database, and associates it to an account.

Later on, whenever a user contacts the Bank and needs to prove her identity, the User proves knowledge of $sk_u$ that corresponds to $pk_u$ using the PoKoDLR protocol using only one base and Pedersen commitments.

\subsubsection{Withdraw}
To withdraw a coin, a user contacts the Bank. Before this, the User must have been registered with the Bank. First, the User proves her identity to the Bank. Then, the User and the Bank execute the following randomization procedure:


\begin{algorithm}[H]\label{randomizeTogether}
\SetKwComment{Comment}{}{}
\SetKwInput{Pre}{Pre-conditions}
\SetKwInput{Post}{Post-conditions}
\dontprintsemicolon

\KwIn{Both parties know the definition of the prime-order group. The User knows his secret key $sk_u$ registered with the bank.}
\Pre{The group must be generated by a trusted third party, or the Prover must verify that each $g_i,h$ has order $ \primeOrder $ in a prime-order group.}
\KwOut{The User's output is $s,t,A$, the Bank's output is $A$.}
\BlankLine

\Comment{Randomize Together} \;
\Indp
  The User picks secrets $s'$ and $t$ from $Z_\primeOrder^*$. \;
  The User creates a Pedersen commitment to $sk_u, s', t$. Call this commitment $A'$. The User sends $A'$ to the Bank. \;
  The Bank picks a random number $r'$ from $Z_\primeOrder^*$. The Bank sends $r'$ to the User. \;
  The User sets $ s = s' + r' $. The User and the Bank independently compute $ A = A' * g^{r'} $. \;
  The User's output is $s,t,A$, the Bank's output is $A$. \;
\Indm

\caption{Randomization procedure between the User and the Bank. This procedure needs to be executed for each wallet, before the withdrawal.}
\end{algorithm}

After the Randomize Together protocol, the User gets a blind CL signature from the Bank. The User starts with the commitment $A$, which he needs to prove that the secrets in $A$ correspond to the the secrets he committed to in the CL signature protocol, and the first secret corresponds to his secret key. Furthermore, the User also sends the Bank a wallet size $W$, which must be picked from a choice of wallet sizes (\eg 1,10,100,1000,10000) and must be at most the User's current account balance. After checking the User's balance, the Bank signs $sk_u,s,t,W$ using blind CL signatures (where $W$ is public input), and decrements the User's account balance. At the end of the Withdraw protocol, the User's wallet is composed of $sk_u,s,t,W,\sigma(sk_u,s,t,W)$ where $\sigma(sk_u,s,t,W)$ denotes the Bank's CL signature on $sk_u,s,t,W$, and a data structure to keep track of spent and remaining coins in the wallet (even though this can be a simple counter, we would like to spend coins with random indices, and so we need to keep a shuffled list of coin indices).



\subsubsection{Spend}
This is the protocol between a user and a merchant. To prevent man-in-the-middle attacks, before the exchange of the money, the User and the Merchant perform a secure key exchange protocol without setup. This can be a simple Diffie-Hellman key exchange over an RSA group using fresh randomly generated keys for both parties. Let the session secret derived from the key exchange be $\ses = \hash(\text{session key})$.

At the beginning, the Merchant picks a random $\info$ and sends this to the User. Both the Merchant and the User computes $R = \hash(\ses,\info)$. Note that only the User and the Merchant can compute this value. Furthermore, the Merchant needs to use a different $\info$ for every transaction. This is to prevent man-in-the-middle attacks.

Next, the User picks the next unused coin index (\ie the next random index in the shuffled list of coin indices). Call this index $J$.



\begin{algorithm}[H]\label{spendCompact}
\SetKwComment{Comment}{}{}
\SetKwInput{Pre}{Pre-conditions}
\SetKwInput{Post}{Post-conditions}
\dontprintsemicolon

\KwIn{Both parties know the definition of the prime-order group, and the Bank's CL signature public key $CLPK$. The User knows her wallet $sk_u,s,t,W,\sigma(sk_u,s,t,W)$, and the index $J$. Both parties know $R = \hash(\info,\ses)$.}
\Pre{The User must have withdrawn a wallet from the Bank, and the wallet must contain an unused coin. Furthermore, $R$ must be computed as directed above.}
\KwOut{The Merchant outputs $coin = B,C,D,W,S,T,J,\pi_{CL},\pi_{ST},\info,\ses$.}
\BlankLine

\Comment{Spend Compact E-Cash} \;
\Indp
  The User creates Pedersen commitments $B$ to $sk_u$, $C$ to $s$, and $D$ to $t$. The User prepares a non-interactive proof of knowledge of a CL signature on these values, where $W$ is a public value. Call this proof $\pi_{CL}$. \;
  The User computes $S = g^{1/(s+J)}$ and $T = pk_u * g^{R/(t+J)}$. \;
  The User prepares a non-interactive proof that $S,T$ are formed correctly. This is done by proving the knowledge of $s,t,sk_u,r_B,\alpha,r_1,\beta,r_2$ such that $B = g^{sk_u} * h^{r_B}$, $g = (g^J * C)^{\alpha} h^{r_1}$ (the Prover knows $r_1 = - r_C / (s+J) \mod \primeOrder$), $g = (g^J * D)^{\beta} h^{r_2}$ (the Prover knows $r_2 = - r_D / (t+J) \mod \primeOrder$), $S = g^{\alpha}$, $T = g^{sk_u} * (g^R)^{\beta}$. Call this proof $\pi_{ST}$. \;
  The User sends $B,C,D,W,S,T,J,\pi_{CL},\pi_{ST}$ to the Merchant. \;
  The Merchant checks if the coin index is correct: $0 \leq J < W$, the proof of knowledge of the CL signature $\pi_{CL}$ verifies, and $S,T$ are correct under the proof $\pi_{ST}$. If all these are satisfied, the Merchant stores $coin = B,C,D,W,S,T,J,\pi_{CL},\pi_{ST},\info,\ses$. \nllabel{earnCompact} \;
\Indm

\caption{Spend-Earn procedure between the User and the Merchant for Compact E-Cash.}
\end{algorithm}



\subsubsection{Deposit}
Depositing the coin is very easy. The Merchant contacts the Bank over a secure and one-way authenticated channel (\ie SSL), proves his identity to the Bank, and then sends the coin to the Bank ($coin = B,C,D,W,S,T,J,\pi_{CL},\pi_{ST},\info,\ses$). The Bank performs the exact check on line \ref{earnCompact} of the Spend protocol in Algorithm \ref{spendCompact}. This verifies that the coin is formed correctly.

The bank then performs double-spending checks. First, the bank checks if $S$ appears in the list of deposited coins. If it does not exist in the deposited coins database, the Bank credits the Merchant's account, and adds the coin to the database. If $S$ indeed does exist, it exists together with an $R'$. If $R = R'$, then the Merchant is trying to deposit twice, and thus the Bank rejects the deposit. Otherwise, $R \neq R'$, and so the User double-spent the coin. The Bank runs the following Identify Double-Spender algorithm to find the public key (and hence the account) of the double-spender. An appropriate punishment can be performed afterwards.


\begin{algorithm}[H]\label{identifyCompact}
\SetKwComment{Comment}{}{}
\SetKwInput{Pre}{Pre-conditions}
\SetKwInput{Post}{Post-conditions}
\dontprintsemicolon

\KwIn{Two coins $coin_1,coin_2$ with the same serial number $S$ but different $R_1,T_1$ and $R_2,T_2$.}
\KwOut{the public key of the double-spender $pk_u$, and proof of double-spending $\pi_{DS} = coin_1,coin_2$.}
\BlankLine

\Comment{Identify Double-Spender} \;
\Indp
  Verify the coins, if not already verified. \;
  The Bank computes $pk_u = (T_2^{R_1} / T_1^{R_2})^{(R_1 - R_2)^{-1}} \mod \primeMod$. \;
  The Bank outputs the public key of the double-spender $pk_u$, and proof of double-spending $\pi_{DS} = coin_1,coin_2$. \;
\Indm

\caption{Identify Double-Spender procedure run by the Bank.}
\end{algorithm}


Given the proof of double-spending, anyone can run the Identify Double-Spender protocol and be assured that the user with public key $pk_u$ has really double-spent. This is because the coins require the knowledge of the secret key of the user.
