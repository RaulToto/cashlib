\subsection{Proof of Knowledge of Discrete Logarithm Representation}\label{sec-PoKoDLR}

This is the protocol used for proving knowledge of the discrete logarithm
representation of a number using some well-defined bases in an honest verifier
zero knowledge way \cite{schnorr:sigs:joc91}. The Verifier knows the number and the bases. We call this protocol \textbf{PoKoDLR}. It has two versions:

The RSA group version uses Fujisaki-Okamoto commitments. Therefore it requires the same setup and the same assumptions. Everything said for the Fujisaki-Okamoto commitments also applies here.

The prime-order group version uses Pedersen commitments. Therefore it requires the same setup and the same assumptions. Everything said for the Pedersen commitments also applies here.

All operations will be done in respective groups.


\textsc{Assumptions}:\\
RSA group version makes the Strong RSA assumption.\\
Prime-order group version makes no assumptions.


\textsc{Honest-Verifier Zero Knowledge}:\\
RSA group version is honest verifier zero knowledge provided that the Fujisaki-Okamoto commitment is hiding. This means that the RSA group must be generated by a trusted third party or it must be proven to the Prover that each $g_i,h$ generates $QR_n$.\\
Prime-order group version is honest verifier zero knowledge provided that the Pedersen commitment is hiding. This means that the prime-order group must be generated by a trusted third party or the Prover must verify that each $g_i,h$ has order $ \primeOrder $.



\textsc{Soundness}:\\
In RSA group version, the extraction works under the Strong RSA assumption, which requires that the RSA group may NOT be generated by the Prover.\\
In prime-order group version, the extraction works without any assumption.



\textsc{*Warnings}:\\
In many uses of the prime-order group version of this protocol, for it to be meaningful, we would like the Pedersen commitments to be binding, which means the Prover may NOT generate $g_i,h$ (and thus know the relative discrete logarithms of the bases), and that the Discrete Logarithm assumption holds.



\begin{table}
\begin{tabular}{l | l | l | l}
Version & Commitments Used & HVZK Condition & Soundness Condition \\
\hline
RSA Group & Fujisaki-Okamoto & Fujisaki-Okamoto is hiding & Strong RSA \\
Prime-order Group & Pedersen & Pedersen is hiding & None or DLog* \\
\end{tabular}
\caption{PoKoDLR Protocol Security Summary}
\end{table}



\begin{algorithm}[H]\label{randProofPoKoDLR}
\SetKwComment{Comment}{}{}
\SetKwInput{Pre}{Pre-conditions}
\SetKwInput{Post}{Post-conditions}
\dontprintsemicolon

\KwIn{Definition of the group, number of secrets $k$, bases $g_1,\ldots,g_k,h$}
\Pre{The group must be generated by a trusted third party, or it must be proven to the Prover that each $g_i,h$ generates $QR_n$ in a special RSA group, or the Prover must verify that each $g_i,h$ has order $ \primeOrder $ in a prime-order group.}
\KwOut{randomized proof $R$, its opening $openR$}
\BlankLine

\Comment{Randomize Proof} \;
\Indp
  \For{$i$ : $1..k$}
    {Pick a random number $s_i$ from domain of randomness $D_R$. \;}
  Create a random element $R$ using Randomize(group definition, $k+1$, $g_1,\ldots,g_k,h$) as in Algorithm \ref{randomize}. Let the random exponents returned by the Randomize procedure be $openR = s_1,\ldots,s_k,t$. \;
  Output randomized proof $R$ and its opening $openR$. \;
\Indm

\caption{Randomized Proof round of PoKoDLR protocol. This procedure is run by the Prover.}
\end{algorithm}




\begin{algorithm}[H]\label{respondPoKoDLR}
\SetKwComment{Comment}{}{}
\SetKwInput{Pre}{Pre-conditions}
\SetKwInput{Post}{Post-conditions}
\dontprintsemicolon

\KwIn{Definition of the group, number of secrets $k$, bases $g_1,\ldots,g_k,h$, opening $open = x_1,\ldots,x_k,r$, randomized proof $R$ and its opening $openR = s_1,\ldots,s_k,t$, challenge $c$}
\Pre{The group must be generated by a trusted third party, or it must be proven to the Prover that each $g_i,h$ generates $QR_n$ in a special RSA group, or the Prover must verify that each $g_i,h$ has order $ \primeOrder $ in a prime-order group.}
\KwOut{response $A$}
\BlankLine

\Comment{Respond} \;
\Indp
  \For{$i$ : $1..k$}
    {Compute $a_i = s_i + c x_i$ \;}
  Compute $b = t + c r$ \;
  [ In prime-order group version, let $ a_i = a_i \mod \primeOrder $ and $ b = b \mod \primeOrder $ ] \;
  Output response $ A = a_1,\ldots,a_k,b $ \;
\Indm

\caption{Response round of PoKoDLR protocol. This procedure is run by the Prover.}
\end{algorithm}



\begin{algorithm}[H]\label{verifyPoKoDLR}
\SetKwComment{Comment}{}{}
\SetKwInput{Pre}{Pre-conditions}
\SetKwInput{Post}{Post-conditions}
\dontprintsemicolon

\KwIn{Definition of the group, number of secrets $k$, bases $g_1,\ldots,g_k,h$, commitment $C$, randomized proof $R$, challenge $c$, response $A = a_1,\ldots,a_k,b$}
\Pre{The RSA group may NOT be generated by the Prover}
\KwOut{$\accept$ or $\reject$}
\BlankLine

\Comment{Verify} \;
\Indp
  \If{$R C^c = h^b \prod_{i=1}^{k} g_i^{a_i}$ ($\mod n$ for RSA group version, $\mod \primeMod$ for Prime-order group version)}
    {Output $\accept$ \;}
  \Else
    {Output $\reject$ \;}
\Indm

\caption{Verification of PoKoDLR protocol. This procedure is run by the Verifier upon receipt of response $A$ from the Prover.}
\end{algorithm}
 



\textsc{Warnings}:\\
In prime-order group version of this protocol, it's important for both parties to make sure that each $x_i,r,s_i,t$ is between $1$ and $ \primeOrder-1 $. Prover can only prove knowledge of $x_i$ that is in that range.

