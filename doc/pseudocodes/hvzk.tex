\section{Honest-Verifier Zero Knowledge $\Sigma$-Proofs}

In these $\Sigma$-protocols, both the Prover and the Verifier know the definition of the group used, as well as some common information (typically a commitment) $C$. In all honest-verifier zero knowledge $\Sigma$-proofs, the Prover first sends a randomized proof $R$. The Verifier then replies with a challenge $c$ (which is always generated in the same way). The Prover then responds to that challenge with some value $A$. Finally, the Verifier verifies the whole proof.


\begin{algorithm}[H]\label{randProofHV}
\SetKwComment{Comment}{}{}
\dontprintsemicolon

\KwIn{Definition of the group, number of secrets $k$, bases $g_1,\ldots,g_k,h$,}
\KwOut{randomized proof $R$, its opening $openR$}
\BlankLine

\Comment{Randomize Proof} \;
\Indp
  Will be defined separately for each protocol.
\Indm

\caption{Randomized Proof round of a $\Sigma$-protocol. This procedure is run by the Prover.}
\end{algorithm}



\begin{algorithm}[H]\label{challengeHV}
\SetKwComment{Comment}{}{}
\SetKwInput{Pre}{Pre-conditions}
\SetKwInput{Post}{Post-conditions}
\dontprintsemicolon

\KwIn{Definition of the group, number of secrets $k$, bases $g_1,\ldots,g_k,h$, commitment $C$, randomized proof $R$}
\Pre{In many protocols we use, the group may not be generated by the Prover. See the specific protocol specification for more on this.}
\KwOut{challenge $c$}
\Post{$C,R$ and $c$ should be kept for use in the verification procedure.}
\BlankLine

\Comment{Challenge} \;
\Indp
  Pick a random number $c$ from the domain of challenges $D_C$. \;
  Output challenge $c$ \;
\Indm

\caption{Challenge round of a 3-round $\Sigma$-protocol. This procedure is run by the Verifier upon receipt of randomized proof $R$ from the Prover.}
\end{algorithm}


\textsc{Domain of Challenges $D_C$}:\\
If an RSA group is used, the domain of challenges is $D_C = \{0,1\}^{\stat}$ (with the exception that the challenge must not be $0$). If a prime-order group is used, the domain of challenges is $D_C = Z_{\primeOrder}^*$ (actually $D_C = \{0,1\}^{\stat}$ will also work). When using non-interactive proofs, $D_C = \{0,1\}^{2*\stat}$ will be used, which will be the same as $D_C = Z_{\primeOrder}^*$. This means that in practice it will make sense to simply use $D_C = \{0,1\}^{2*\stat} - \{0\}$ for both groups.


\textsc{Domain of Randomness $D_R$}:\\
If an RSA group is used, the domain of randomness is $D_R = \{0,1\}^{\RSALength + \stat}$ (except again the randomness must not be $0$). If a prime-order group is used, the domain of randomness is $D_R = Z_{\primeOrder}^*$. Note that, unlike the challenge domains, these domains are very different for both groups, and that the prime-order group is more efficient in terms of both computation and communication.


\textsc{Non-Interactive Version}:\\
If non-interactive proofs will be employed using the Fiat-Shamir heuristic \cite{fiatShamir}, the challenge will be computed as $c = hash(\text{definition of the group and bases used} \cc k \cc C \cc R)$. This computation can be carried out by the Prover and the Verifier separately, and then the Verifier can verify the proof as before. It is important to note that if the Fiat-Shamir heuristic is used, the resulting protocol is secure only in the Random Oracle model \cite{brRO,cghRO}.


\textsc{Full Zero Knowledge}:\\
Techniques for converting honest-verifier zero-knowledge proofs to full zero-knowledge proofs (\ie using trapdoor commitments as in \cite{damgardTC}) should be applied for the interactive versions. Non-interactive versions using the Fiat-Shamir heuristic do not require this conversion, since the Random Oracle model essentially forces the Verifier to be honest. Since all the proofs we will use are non-interactive, we do not provide full zero-knowledge protocols here.



\begin{algorithm}[H]\label{respondHV}
\SetKwComment{Comment}{}{}
\dontprintsemicolon

\KwIn{Definition of the group, number of secrets $k$, bases $g_1,\ldots,g_k,h$, opening of $C$: $openC$, randomized proof $R$ and its opening $openR$, challenge $c$}
\KwOut{response $A$}
\BlankLine

\Comment{Respond} \;
\Indp
  Will be defined separately for each protocol.
\Indm

\caption{Response round of a $\Sigma$-protocol. This procedure is run by the Prover.}
\end{algorithm}


\begin{algorithm}[H]\label{verifyHV}
\SetKwComment{Comment}{}{}
\dontprintsemicolon

\KwIn{Definition of the group, number of secrets $k$, bases $g_1,\ldots,g_k,h$, commitment $C$, randomized proof $R$, challenge $c$, response $A$}
\KwOut{$\accept$ or $\reject$}
\BlankLine

\Comment{Verify} \;
\Indp
  Will be defined separately for each protocol.
\Indm

\caption{Verification of a $\Sigma$-protocol. This procedure is run by the Verifier upon receipt of response $A$ from the Prover.}
\end{algorithm}


\textsc{Non-Interactive Verification}:\\
When verifying non-interactive proofs, the verification procedure is called with challenge $c = hash(\text{definition of the group and bases used} \cc k \cc C \cc R)$, and the rest proceeds the same as the interactive version.


